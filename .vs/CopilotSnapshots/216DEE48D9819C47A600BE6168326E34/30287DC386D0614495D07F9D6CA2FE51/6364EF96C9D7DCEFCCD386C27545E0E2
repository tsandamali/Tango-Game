const { v4: uuidv4 } = require('uuid');
const { generatePuzzle } = require('../utils/puzzleGenerator');
const config = require('../config/config');

// In-memory storage
const games = new Map();
const playerSessions = new Map();

class GameService {
  static createGame() {
    const gameId = uuidv4();
    const round1Puzzle = generatePuzzle(1);
    const round2Puzzle = generatePuzzle(2);
    const round3Puzzle = generatePuzzle(3);

    games.set(gameId, {
      id: gameId,
      currentRound: 1,
      totalRounds: 3,
      rounds: {
        1: {
          puzzle: round1Puzzle,
          status: 'waiting', // waiting, countdown, active, finished
          startTime: null,
          completedPlayers: new Set()
        },
        2: {
          puzzle: round2Puzzle,
          status: 'active',
          startTime: null,
          completedPlayers: new Set()
        },
        3: {
          puzzle: round3Puzzle,
          status: 'active',
          startTime: null,
          completedPlayers: new Set()
        }
      },
      status: 'waiting',
      players: new Map(),
      countdownTime: config.game.defaultCountdownTime,
      createdAt: Date.now()
    });

    return { gameId, game: games.get(gameId) };
  }

  static getGame(gameId) {
    return games.get(gameId);
  }

  static startGame(gameId) {
    const game = games.get(gameId);
    if (!game || game.status !== 'waiting') {
      return null;
    }

    game.status = 'countdown';
    return game;
  }

  static activateGame(gameId) {
    const game = games.get(gameId);
    if (!game) return null;

    if (game.currentRound === 1) {
      game.status = 'round1-active';
      game.rounds[1].status = 'active';
      game.rounds[1].startTime = Date.now();
    } else if (game.currentRound === 2) {
      game.status = 'round2-active';
      game.rounds[2].status = 'active';
      game.rounds[2].startTime = Date.now();
    } else if (game.currentRound === 3) {
      game.status = 'round3-active';
      game.rounds[3].status = 'active';
      game.rounds[3].startTime = Date.now();
    }

    return game;
  }

  static addPlayer(gameId, playerName, socketId) {
    const game = this.getGame(gameId);
    if (!game) return null;

    const nameExists = Array.from(game.players.values())
        .some(p => p.name.toLowerCase() === playerName.toLowerCase());

    if (nameExists) {
      return { error: 'Name already taken' };
    }

    const playerId = uuidv4(); // however you generate ID

    const player = {
      id: playerId,
      name: playerName,
      socketId,
      completionTime: null,
      round2CompletionTime: null,
      round3CompletionTime: null
    };

    game.players.set(playerId, player);
    return player;
  }

  static startPlayerRound2(gameId, playerId) {
    const game = games.get(gameId);
    if (!game) return null;

    const player = game.players.get(playerId);
    if (!player) return null;

    player.round2StartTime = Date.now();
    player.round2Status = 'active';
    return game;
  }

  static startPlayerRound3(gameId, playerId) {
    const game = games.get(gameId);
    if (!game) return null;

    const player = game.players.get(playerId);
    if (!player) return null;

    player.round3StartTime = Date.now();
    player.round3Status = 'active';
    return game;
  }

  static submitSolution(gameId, playerId, solution, round) {
    const game = games.get(gameId);
    const currentRound = round || game.currentRound;

    if (!game) {
      return { success: false, error: 'Game not found' };
    }

    const roundData = game.rounds[currentRound];
    if (!roundData) {
      return { success: false, error: 'Round not found' };
    }

    const player = game.players.get(playerId);
    if (!player) {
      return { success: false, error: 'Invalid player' };
    }

    // Check if already completed
    let isAlreadyCompleted = false;
    if (currentRound === 1) {
      isAlreadyCompleted = player.status === 'completed';
    } else if (currentRound === 2) {
      isAlreadyCompleted = player.round2Status === 'completed';
    } else if (currentRound === 3) {
      isAlreadyCompleted = player.round3Status === 'completed';
    }

    if (isAlreadyCompleted) {
      return { success: false, error: 'Already completed' };
    }

    // Replace exact-solution validation with rule-based validation
    const isCorrect = this.validateTangoSolution(solution, roundData.puzzle);
    if (!isCorrect) {
      return { success: false, error: 'Incorrect solution' };
    }

    // Calculate completion time
    let completionTime;
    if (currentRound === 1) {
      completionTime = Date.now() - game.rounds[1].startTime;
      player.completionTime = completionTime;
      player.status = 'completed';
      roundData.completedPlayers.add(playerId);
    } else if (currentRound === 2) {
      completionTime = Date.now() - player.round2StartTime;
      player.round2CompletionTime = completionTime;
      player.round2Status = 'completed';
      roundData.completedPlayers.add(playerId);
    } else if (currentRound === 3) {
      completionTime = Date.now() - player.round3StartTime;
      player.round3CompletionTime = completionTime;
      player.round3Status = 'completed';
      roundData.completedPlayers.add(playerId);
      player.totalTime = player.completionTime + player.round2CompletionTime + player.round3CompletionTime;
      this.calculateFinalRankings(game);
    }
    const completedPlayers = Array.from(game.players.values())
      .filter(p => {
        if (currentRound === 1) return p.status === 'completed';
        if (currentRound === 2) return p.round2Status === 'completed';
        if (currentRound === 3) return p.round3Status === 'completed';
      })
      .sort((a, b) => {
        const timeA = currentRound === 1 ? a.completionTime : currentRound === 2 ? a.round2CompletionTime : a.round3CompletionTime;
        const timeB = currentRound === 1 ? b.completionTime : currentRound === 2 ? b.round2CompletionTime : b.round3CompletionTime;
        return timeA - timeB;
      });

    completedPlayers.forEach((p, index) => {
      const rankIndex = index + 1;
      if (currentRound === 1) p.rank = rankIndex;
      else if (currentRound === 2) p.round2Rank = rankIndex;
      else if (currentRound === 3) p.round3Rank = rankIndex;
    });

    const allCompleted = roundData.completedPlayers.size === game.players.size;

    return {
      success: true,
      player,
      round: currentRound,
      totalPlayers: game.players.size,
      allCompleted,
      moveToRound2: currentRound === 1, // Signal to move to round 2
      moveToRound3: currentRound === 2  // Signal to move to round 3
    };
  }

  static calculateFinalRankings(game) {
    Array.from(game.players.values())
      .filter(p => p.totalTime !== null)
      .sort((a, b) => a.totalTime - b.totalTime)
      .forEach((player, index) => player.totalRank = index + 1);
  }

  static validateTangoSolution(userSolution, correctSolution) {
    // New behavior: validate by rules rather than exact original solution
    const puzzle = correctSolution; // second arg is actually the puzzle object when called
    if (!userSolution || !puzzle) return false;

    const size = puzzle.size;
    if (!Array.isArray(userSolution) || userSolution.length !== size) return false;

    // No empty cells
    for (let r = 0; r < size; r++) {
      if (!Array.isArray(userSolution[r]) || userSolution[r].length !== size) return false;
      for (let c = 0; c < size; c++) {
        const v = userSolution[r][c];
        if (v !== 1 && v !== 2) return false; // must be sun or moon
      }
    }

    const half = size / 2;

    // Check rows and columns for equal counts and no three-in-a-row
    for (let r = 0; r < size; r++) {
      let sun = 0, moon = 0;
      for (let c = 0; c < size; c++) {
        const v = userSolution[r][c];
        if (v === 1) sun++;
        else if (v === 2) moon++;

        // horizontal three-in-a-row check
        if (c <= size - 3) {
          if (userSolution[r][c] === userSolution[r][c+1] && userSolution[r][c] === userSolution[r][c+2]) return false;
        }
      }
      if (sun !== half || moon !== half) return false;
    }

    for (let c = 0; c < size; c++) {
      let sun = 0, moon = 0;
      for (let r = 0; r < size; r++) {
        const v = userSolution[r][c];
        if (v === 1) sun++;
        else if (v === 2) moon++;

        // vertical three-in-a-row check
        if (r <= size - 3) {
          if (userSolution[r][c] === userSolution[r+1][c] && userSolution[r][c] === userSolution[r+2][c]) return false;
        }
      }
      if (sun !== half || moon !== half) return false;
    }

    // Check constraints provided by puzzle (if any)
    const constraints = puzzle.constraints || {};
    if (constraints.horizontal) {
      for (const constraint of constraints.horizontal) {
        const left = userSolution[constraint.row][constraint.col];
        const right = userSolution[constraint.row][constraint.col + 1];
        if (constraint.type === 'equal' && left !== right) return false;
        if (constraint.type === 'different' && left === right) return false;
      }
    }
    if (constraints.vertical) {
      for (const constraint of constraints.vertical) {
        const top = userSolution[constraint.row][constraint.col];
        const bottom = userSolution[constraint.row + 1][constraint.col];
        if (constraint.type === 'equal' && top !== bottom) return false;
        if (constraint.type === 'different' && top === bottom) return false;
      }
    }

    return true;
  }

  static getLeaderboard(gameId) {
    const game = games.get(gameId);
    if (!game) return null;

    return Array.from(game.players.values())
      .filter(p => p.status === 'completed')
      .sort((a, b) => a.completionTime - b.completionTime)
      .map(p => ({
        name: p.name,
        completionTime: p.completionTime,
        rank: p.rank
      }));
  }

  static getPlayerSession(socketId) {
    return playerSessions.get(socketId);
  }

  static removePlayerSession(socketId) {
    playerSessions.delete(socketId);
  }

  static getGamePlayers(gameId) {
    const game = games.get(gameId);
    if (!game) return [];

    return Array.from(game.players.values()).map(p => {
      // Ensure default status fields
      const r1 = p.completionTime || null;
      const r2 = p.round2CompletionTime || null;
      const r3 = p.round3CompletionTime || null;

      // derive statuses
      const statusR1 = p.status || (game.currentRound === 1 && game.rounds[1].status === 'active' ? 'active' : 'waiting');
      const statusR2 = p.round2Status || null;
      const statusR3 = p.round3Status || null;

      // overall status and display
      let overallStatus = 'waiting';
      let displayStatus = 'Waiting';
      let displayCompletionTime = null; // in ms

      if (statusR3 === 'completed') {
        overallStatus = 'completed';
        displayStatus = 'Completed';
        displayCompletionTime = (r1 || 0) + (r2 || 0) + (r3 || 0);
      } else if (statusR2 === 'completed') {
        overallStatus = 'round2-completed';
        displayStatus = 'Round 2 Completed';
        displayCompletionTime = (r1 || 0) + (r2 || 0);
      } else if (statusR1 === 'completed') {
        overallStatus = 'round1-completed';
        displayStatus = 'Round 1 Completed';
        displayCompletionTime = r1;
      } else if (statusR2 === 'active' || p.round2StartTime) {
        overallStatus = 'round2-active';
        displayStatus = 'Round 2 Active';
        displayCompletionTime = r1; // show round1 time while in round2
      } else if (statusR1 === 'active' || game.rounds[1].status === 'active') {
        overallStatus = 'round1-active';
        displayStatus = 'Round 1 Active';
        displayCompletionTime = null;
      }

      return {
        id: p.id,
        name: p.name,
        status: overallStatus,
        displayStatus,
        completionTime: r1,
        round2CompletionTime: r2,
        round3CompletionTime: r3,
        displayCompletionTime, // ms or null
        rank: p.rank || null,
        round2Rank: p.round2Rank || null,
        round3Rank: p.round3Rank || null,
        totalTime: (r1 || 0) + (r2 || 0) + (r3 || 0),
        totalRank: p.totalRank || null
      };
    });
  }
}

module.exports = GameService;
